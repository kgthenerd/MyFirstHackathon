buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "com.avast.gradle:docker-compose-gradle-plugin:0.4.2"
        classpath "com.moowork.gradle:gradle-node-plugin:1.1.0"
        classpath 'com.bmuschko:gradle-docker-plugin:3.0.7'
    }
}

apply plugin: 'java'
apply plugin: 'docker-compose'
apply plugin: "com.moowork.node"

node {
  version = '4.4.5'
  npmVersion = '4.2.0'
  download = true
  // distBaseUrl = Custom artifactory location here for node/npm.
}

// Or use the new Gradle Portal plugins:
// plugins {
//  id 'com.avast.gradle.docker-compose' version "$versionHere"
// }

dockerCompose.isRequiredBy(test) // hooks 'dependsOn composeUp' and 'finalizedBy composeDown'

dockerCompose {
    useComposeFiles = ['docker-compose.yml'] // like 'docker-compose -f <file>'
    // captureContainersOutput = true // prints output of all containers to Gradle output - very useful for debugging
    // stopContainers = false // doesn't call `docker-compose down` - useful for debugging
    // removeContainers = false
    // removeImages = "None" // Other accepted values are: "All" and "Local"
    // removeOrphans = false // Removes containers for services not defined in the Compose file
    // removeVolumes = false
    // projectName = 'my-project' // allow to set custom docker-compose project name (defaults to directory name)
    // executable = '/path/to/docker-compose' // allow to set the path of the docker-compose executable (usefull if not present in PATH)
    // dockerExecutable = '/path/to/docker' // allow to set the path of the docker executable (usefull if not present in PATH)
    // dockerComposeWorkingDirectory = '/path/where/docker-compose/is/invoked/from'
    dockerComposeStopTimeout = java.time.Duration.ofSeconds(20) // time before docker-compose sends SIGTERM to the running containers after the composeDown task has been started
    // environment.put 'BACKEND_ADDRESS', '192.168.1.100' // Pass environment variable to 'docker-compose' for substitution in compose file
    // scale = [${serviceName1}: 5, ${serviceName2}: 2] // Pass docker compose --scale option like 'docker-compose up --scale serviceName1=5 --scale serviceName2=2'
}

test.doFirst {
    // exposes "${serviceName}_HOST" and "${serviceName}_TCP_${exposedPort}" environment variables
    // for example exposes "WEB_HOST" and "WEB_TCP_80" environment variables for service named `web` with exposed port `80`
    // if service is scaled using scale option, environment variables will be exposed for each service instance like "WEB_1_HOST", "WEB_1_TCP_80", "WEB_2_HOST", "WEB_2_TCP_80" and so on
    dockerCompose.exposeAsEnvironment(test)
    // exposes "${serviceName}.host" and "${serviceName}.tcp.${exposedPort}" system properties
    // for example exposes "web.host" and "web.tcp.80" system properties for service named `web` with exposed port `80`
    // if service is scaled using scale option, environment variables will be exposed for each service instance like "web_1.host", "web_1.tcp.80", "web_2.host", "web_2.tcp.80" and so on
    dockerCompose.exposeAsSystemProperties(test)
    // get information about container of service `web` (declared in docker-compose.yml)
    def webInfo = dockerCompose.servicesInfos.web.firstInstance
    // pass host and exposed TCP port 80 as custom-named Java System properties
    systemProperty 'myweb.host', webInfo.host
    systemProperty 'myweb.port', webInfo.ports[3000]    
}

task testUnit(type: NpmTask) {
    args = ['run', 'test']
}

task buildDockerImage(type: DockerBuildImage) {
    dependsOn testUnit
    if (System.env.DOCKER_HOST) {
        url = "$System.env.DOCKER_HOST".replace("tcp","https")
        if (System.env.DOCKER_CERT_PATH) {
            certPath = new File(System.env.DOCKER_CERT_PATH)

        }
    }
    else {
        url = 'unix:///var/run/docker.sock'
    }
    inputDir = file('.')
    //tag = 'mesos/elasticsearch-scheduler'
}

test.dependsOn testUnit
build.dependsOn buildDockerImage